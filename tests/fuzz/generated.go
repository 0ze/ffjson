// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: fuzz.go

package fuzz

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"reflect"
	"time"
)

// MarshalJSON marshal bytes to json - template
func (j *Data) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Data) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"A":`)
	fflib.FormatBits2(buf, uint64(j.A), 10, false)
	buf.WriteString(`,"B":`)
	fflib.FormatBits2(buf, uint64(j.B), 10, false)
	buf.WriteString(`,"C":`)
	fflib.FormatBits2(buf, uint64(j.C), 10, false)
	buf.WriteString(`,"D":`)
	fflib.FormatBits2(buf, uint64(j.D), 10, false)
	buf.WriteString(`,"E":`)
	fflib.FormatBits2(buf, uint64(j.E), 10, j.E < 0)
	buf.WriteString(`,"F":`)
	fflib.FormatBits2(buf, uint64(j.F), 10, j.F < 0)
	buf.WriteString(`,"G":`)
	fflib.FormatBits2(buf, uint64(j.G), 10, j.G < 0)
	buf.WriteString(`,"H":`)
	fflib.FormatBits2(buf, uint64(j.H), 10, j.H < 0)
	buf.WriteString(`,"I":`)
	fflib.AppendFloat(buf, float64(j.I), 'g', -1, 32)
	buf.WriteString(`,"J":`)
	fflib.AppendFloat(buf, float64(j.J), 'g', -1, 64)
	buf.WriteString(`,"M":`)
	fflib.FormatBits2(buf, uint64(j.M), 10, false)
	buf.WriteString(`,"N":`)
	fflib.FormatBits2(buf, uint64(j.N), 10, j.N < 0)
	buf.WriteString(`,"O":`)
	fflib.FormatBits2(buf, uint64(j.O), 10, j.O < 0)
	buf.WriteString(`,"P":`)
	fflib.FormatBits2(buf, uint64(j.P), 10, false)
	buf.WriteString(`,"Q":`)
	fflib.WriteJsonString(buf, string(j.Q))
	if j.R {
		buf.WriteString(`,"R":true`)
	} else {
		buf.WriteString(`,"R":false`)
	}
	buf.WriteString(`,"S":`)

	{

		obj, err = j.S.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Ap != nil {
		buf.WriteString(`,"Ap":`)
		fflib.FormatBits2(buf, uint64(*j.Ap), 10, false)
	} else {
		buf.WriteString(`,"Ap":null`)
	}
	if j.Bp != nil {
		buf.WriteString(`,"Bp":`)
		fflib.FormatBits2(buf, uint64(*j.Bp), 10, false)
	} else {
		buf.WriteString(`,"Bp":null`)
	}
	if j.Cp != nil {
		buf.WriteString(`,"Cp":`)
		fflib.FormatBits2(buf, uint64(*j.Cp), 10, false)
	} else {
		buf.WriteString(`,"Cp":null`)
	}
	if j.Dp != nil {
		buf.WriteString(`,"Dp":`)
		fflib.FormatBits2(buf, uint64(*j.Dp), 10, false)
	} else {
		buf.WriteString(`,"Dp":null`)
	}
	if j.Ep != nil {
		buf.WriteString(`,"Ep":`)
		fflib.FormatBits2(buf, uint64(*j.Ep), 10, *j.Ep < 0)
	} else {
		buf.WriteString(`,"Ep":null`)
	}
	if j.Fp != nil {
		buf.WriteString(`,"Fp":`)
		fflib.FormatBits2(buf, uint64(*j.Fp), 10, *j.Fp < 0)
	} else {
		buf.WriteString(`,"Fp":null`)
	}
	if j.Gp != nil {
		buf.WriteString(`,"Gp":`)
		fflib.FormatBits2(buf, uint64(*j.Gp), 10, *j.Gp < 0)
	} else {
		buf.WriteString(`,"Gp":null`)
	}
	if j.Hp != nil {
		buf.WriteString(`,"Hp":`)
		fflib.FormatBits2(buf, uint64(*j.Hp), 10, *j.Hp < 0)
	} else {
		buf.WriteString(`,"Hp":null`)
	}
	if j.IP != nil {
		buf.WriteString(`,"IP":`)
		fflib.AppendFloat(buf, float64(*j.IP), 'g', -1, 32)
	} else {
		buf.WriteString(`,"IP":null`)
	}
	if j.Jp != nil {
		buf.WriteString(`,"Jp":`)
		fflib.AppendFloat(buf, float64(*j.Jp), 'g', -1, 64)
	} else {
		buf.WriteString(`,"Jp":null`)
	}
	if j.Mp != nil {
		buf.WriteString(`,"Mp":`)
		fflib.FormatBits2(buf, uint64(*j.Mp), 10, false)
	} else {
		buf.WriteString(`,"Mp":null`)
	}
	if j.Np != nil {
		buf.WriteString(`,"Np":`)
		fflib.FormatBits2(buf, uint64(*j.Np), 10, *j.Np < 0)
	} else {
		buf.WriteString(`,"Np":null`)
	}
	if j.Op != nil {
		buf.WriteString(`,"Op":`)
		fflib.FormatBits2(buf, uint64(*j.Op), 10, *j.Op < 0)
	} else {
		buf.WriteString(`,"Op":null`)
	}
	if j.Pp != nil {
		buf.WriteString(`,"Pp":`)
		fflib.FormatBits2(buf, uint64(*j.Pp), 10, false)
	} else {
		buf.WriteString(`,"Pp":null`)
	}
	if j.Qp != nil {
		buf.WriteString(`,"Qp":`)
		fflib.WriteJsonString(buf, string(*j.Qp))
	} else {
		buf.WriteString(`,"Qp":null`)
	}
	if j.Rp != nil {
		if *j.Rp {
			buf.WriteString(`,"Rp":true`)
		} else {
			buf.WriteString(`,"Rp":false`)
		}
	} else {
		buf.WriteString(`,"Rp":null`)
	}
	if j.Sp != nil {
		buf.WriteString(`,"Sp":`)

		{

			obj, err = j.Sp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
	} else {
		buf.WriteString(`,"Sp":null`)
	}
	buf.WriteString(`,"Aa":`)
	if j.Aa != nil {
		buf.WriteString(`"`)
		{
			enc := base64.NewEncoder(base64.StdEncoding, buf)
			enc.Write(reflect.Indirect(reflect.ValueOf(j.Aa)).Bytes())
			enc.Close()
		}
		buf.WriteString(`"`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ba":`)
	if j.Ba != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ba {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, false)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ca":`)
	if j.Ca != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ca {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, false)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Da":`)
	if j.Da != nil {
		buf.WriteString(`[`)
		for i, v := range j.Da {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, false)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ea":`)
	if j.Ea != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ea {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Fa":`)
	if j.Fa != nil {
		buf.WriteString(`[`)
		for i, v := range j.Fa {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ga":`)
	if j.Ga != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ga {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ha":`)
	if j.Ha != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ha {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ia":`)
	if j.Ia != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ia {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.AppendFloat(buf, float64(v), 'g', -1, 32)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ja":`)
	if j.Ja != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ja {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.AppendFloat(buf, float64(v), 'g', -1, 64)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ma":`)
	if j.Ma != nil {
		buf.WriteString(`"`)
		{
			enc := base64.NewEncoder(base64.StdEncoding, buf)
			enc.Write(reflect.Indirect(reflect.ValueOf(j.Ma)).Bytes())
			enc.Close()
		}
		buf.WriteString(`"`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Na":`)
	if j.Na != nil {
		buf.WriteString(`[`)
		for i, v := range j.Na {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Oa":`)
	if j.Oa != nil {
		buf.WriteString(`[`)
		for i, v := range j.Oa {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Pa":`)
	if j.Pa != nil {
		buf.WriteString(`[`)
		for i, v := range j.Pa {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, false)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Qa":`)
	if j.Qa != nil {
		buf.WriteString(`[`)
		for i, v := range j.Qa {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ra":`)
	if j.Ra != nil {
		buf.WriteString(`[`)
		for i, v := range j.Ra {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v {
				buf.WriteString(`true`)
			} else {
				buf.WriteString(`false`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Aap":`)
	if j.Aap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Aap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, false)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Bap":`)
	if j.Bap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Bap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, false)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Cap":`)
	if j.Cap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Cap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, false)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Dap":`)
	if j.Dap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Dap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, false)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Eap":`)
	if j.Eap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Eap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, *v < 0)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Fap":`)
	if j.Fap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Fap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, *v < 0)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Gap":`)
	if j.Gap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Gap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, *v < 0)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Hap":`)
	if j.Hap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Hap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, *v < 0)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Iap":`)
	if j.Iap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Iap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.AppendFloat(buf, float64(*v), 'g', -1, 32)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Jap":`)
	if j.Jap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Jap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.AppendFloat(buf, float64(*v), 'g', -1, 64)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Map":`)
	if j.Map != nil {
		buf.WriteString(`[`)
		for i, v := range j.Map {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, false)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Nap":`)
	if j.Nap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Nap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, *v < 0)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Oap":`)
	if j.Oap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Oap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, *v < 0)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Pap":`)
	if j.Pap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Pap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.FormatBits2(buf, uint64(*v), 10, false)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Qap":`)
	if j.Qap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Qap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				fflib.WriteJsonString(buf, string(*v))
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Rap":`)
	if j.Rap != nil {
		buf.WriteString(`[`)
		for i, v := range j.Rap {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				if *v {
					buf.WriteString(`true`)
				} else {
					buf.WriteString(`false`)
				}
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDatabase = iota
	ffjtDatanosuchkey

	ffjtDataA

	ffjtDataB

	ffjtDataC

	ffjtDataD

	ffjtDataE

	ffjtDataF

	ffjtDataG

	ffjtDataH

	ffjtDataI

	ffjtDataJ

	ffjtDataM

	ffjtDataN

	ffjtDataO

	ffjtDataP

	ffjtDataQ

	ffjtDataR

	ffjtDataS

	ffjtDataAp

	ffjtDataBp

	ffjtDataCp

	ffjtDataDp

	ffjtDataEp

	ffjtDataFp

	ffjtDataGp

	ffjtDataHp

	ffjtDataIP

	ffjtDataJp

	ffjtDataMp

	ffjtDataNp

	ffjtDataOp

	ffjtDataPp

	ffjtDataQp

	ffjtDataRp

	ffjtDataSp

	ffjtDataAa

	ffjtDataBa

	ffjtDataCa

	ffjtDataDa

	ffjtDataEa

	ffjtDataFa

	ffjtDataGa

	ffjtDataHa

	ffjtDataIa

	ffjtDataJa

	ffjtDataMa

	ffjtDataNa

	ffjtDataOa

	ffjtDataPa

	ffjtDataQa

	ffjtDataRa

	ffjtDataAap

	ffjtDataBap

	ffjtDataCap

	ffjtDataDap

	ffjtDataEap

	ffjtDataFap

	ffjtDataGap

	ffjtDataHap

	ffjtDataIap

	ffjtDataJap

	ffjtDataMap

	ffjtDataNap

	ffjtDataOap

	ffjtDataPap

	ffjtDataQap

	ffjtDataRap
)

var ffjKeyDataA = []byte("A")

var ffjKeyDataB = []byte("B")

var ffjKeyDataC = []byte("C")

var ffjKeyDataD = []byte("D")

var ffjKeyDataE = []byte("E")

var ffjKeyDataF = []byte("F")

var ffjKeyDataG = []byte("G")

var ffjKeyDataH = []byte("H")

var ffjKeyDataI = []byte("I")

var ffjKeyDataJ = []byte("J")

var ffjKeyDataM = []byte("M")

var ffjKeyDataN = []byte("N")

var ffjKeyDataO = []byte("O")

var ffjKeyDataP = []byte("P")

var ffjKeyDataQ = []byte("Q")

var ffjKeyDataR = []byte("R")

var ffjKeyDataS = []byte("S")

var ffjKeyDataAp = []byte("Ap")

var ffjKeyDataBp = []byte("Bp")

var ffjKeyDataCp = []byte("Cp")

var ffjKeyDataDp = []byte("Dp")

var ffjKeyDataEp = []byte("Ep")

var ffjKeyDataFp = []byte("Fp")

var ffjKeyDataGp = []byte("Gp")

var ffjKeyDataHp = []byte("Hp")

var ffjKeyDataIP = []byte("IP")

var ffjKeyDataJp = []byte("Jp")

var ffjKeyDataMp = []byte("Mp")

var ffjKeyDataNp = []byte("Np")

var ffjKeyDataOp = []byte("Op")

var ffjKeyDataPp = []byte("Pp")

var ffjKeyDataQp = []byte("Qp")

var ffjKeyDataRp = []byte("Rp")

var ffjKeyDataSp = []byte("Sp")

var ffjKeyDataAa = []byte("Aa")

var ffjKeyDataBa = []byte("Ba")

var ffjKeyDataCa = []byte("Ca")

var ffjKeyDataDa = []byte("Da")

var ffjKeyDataEa = []byte("Ea")

var ffjKeyDataFa = []byte("Fa")

var ffjKeyDataGa = []byte("Ga")

var ffjKeyDataHa = []byte("Ha")

var ffjKeyDataIa = []byte("Ia")

var ffjKeyDataJa = []byte("Ja")

var ffjKeyDataMa = []byte("Ma")

var ffjKeyDataNa = []byte("Na")

var ffjKeyDataOa = []byte("Oa")

var ffjKeyDataPa = []byte("Pa")

var ffjKeyDataQa = []byte("Qa")

var ffjKeyDataRa = []byte("Ra")

var ffjKeyDataAap = []byte("Aap")

var ffjKeyDataBap = []byte("Bap")

var ffjKeyDataCap = []byte("Cap")

var ffjKeyDataDap = []byte("Dap")

var ffjKeyDataEap = []byte("Eap")

var ffjKeyDataFap = []byte("Fap")

var ffjKeyDataGap = []byte("Gap")

var ffjKeyDataHap = []byte("Hap")

var ffjKeyDataIap = []byte("Iap")

var ffjKeyDataJap = []byte("Jap")

var ffjKeyDataMap = []byte("Map")

var ffjKeyDataNap = []byte("Nap")

var ffjKeyDataOap = []byte("Oap")

var ffjKeyDataPap = []byte("Pap")

var ffjKeyDataQap = []byte("Qap")

var ffjKeyDataRap = []byte("Rap")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Data) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Data) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeyDataA, kn) {
						currentKey = ffjtDataA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataAp, kn) {
						currentKey = ffjtDataAp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataAa, kn) {
						currentKey = ffjtDataAa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataAap, kn) {
						currentKey = ffjtDataAap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'B':

					if bytes.Equal(ffjKeyDataB, kn) {
						currentKey = ffjtDataB
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataBp, kn) {
						currentKey = ffjtDataBp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataBa, kn) {
						currentKey = ffjtDataBa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataBap, kn) {
						currentKey = ffjtDataBap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffjKeyDataC, kn) {
						currentKey = ffjtDataC
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataCp, kn) {
						currentKey = ffjtDataCp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataCa, kn) {
						currentKey = ffjtDataCa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataCap, kn) {
						currentKey = ffjtDataCap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyDataD, kn) {
						currentKey = ffjtDataD
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataDp, kn) {
						currentKey = ffjtDataDp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataDa, kn) {
						currentKey = ffjtDataDa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataDap, kn) {
						currentKey = ffjtDataDap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffjKeyDataE, kn) {
						currentKey = ffjtDataE
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataEp, kn) {
						currentKey = ffjtDataEp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataEa, kn) {
						currentKey = ffjtDataEa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataEap, kn) {
						currentKey = ffjtDataEap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffjKeyDataF, kn) {
						currentKey = ffjtDataF
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataFp, kn) {
						currentKey = ffjtDataFp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataFa, kn) {
						currentKey = ffjtDataFa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataFap, kn) {
						currentKey = ffjtDataFap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'G':

					if bytes.Equal(ffjKeyDataG, kn) {
						currentKey = ffjtDataG
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataGp, kn) {
						currentKey = ffjtDataGp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataGa, kn) {
						currentKey = ffjtDataGa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataGap, kn) {
						currentKey = ffjtDataGap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'H':

					if bytes.Equal(ffjKeyDataH, kn) {
						currentKey = ffjtDataH
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataHp, kn) {
						currentKey = ffjtDataHp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataHa, kn) {
						currentKey = ffjtDataHa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataHap, kn) {
						currentKey = ffjtDataHap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffjKeyDataI, kn) {
						currentKey = ffjtDataI
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataIP, kn) {
						currentKey = ffjtDataIP
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataIa, kn) {
						currentKey = ffjtDataIa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataIap, kn) {
						currentKey = ffjtDataIap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'J':

					if bytes.Equal(ffjKeyDataJ, kn) {
						currentKey = ffjtDataJ
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataJp, kn) {
						currentKey = ffjtDataJp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataJa, kn) {
						currentKey = ffjtDataJa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataJap, kn) {
						currentKey = ffjtDataJap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffjKeyDataM, kn) {
						currentKey = ffjtDataM
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataMp, kn) {
						currentKey = ffjtDataMp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataMa, kn) {
						currentKey = ffjtDataMa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataMap, kn) {
						currentKey = ffjtDataMap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffjKeyDataN, kn) {
						currentKey = ffjtDataN
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataNp, kn) {
						currentKey = ffjtDataNp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataNa, kn) {
						currentKey = ffjtDataNa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataNap, kn) {
						currentKey = ffjtDataNap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffjKeyDataO, kn) {
						currentKey = ffjtDataO
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataOp, kn) {
						currentKey = ffjtDataOp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataOa, kn) {
						currentKey = ffjtDataOa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataOap, kn) {
						currentKey = ffjtDataOap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyDataP, kn) {
						currentKey = ffjtDataP
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataPp, kn) {
						currentKey = ffjtDataPp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataPa, kn) {
						currentKey = ffjtDataPa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataPap, kn) {
						currentKey = ffjtDataPap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffjKeyDataQ, kn) {
						currentKey = ffjtDataQ
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataQp, kn) {
						currentKey = ffjtDataQp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataQa, kn) {
						currentKey = ffjtDataQa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataQap, kn) {
						currentKey = ffjtDataQap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffjKeyDataR, kn) {
						currentKey = ffjtDataR
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataRp, kn) {
						currentKey = ffjtDataRp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataRa, kn) {
						currentKey = ffjtDataRa
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataRap, kn) {
						currentKey = ffjtDataRap
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyDataS, kn) {
						currentKey = ffjtDataS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDataSp, kn) {
						currentKey = ffjtDataSp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataRap, kn) {
					currentKey = ffjtDataRap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataQap, kn) {
					currentKey = ffjtDataQap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataPap, kn) {
					currentKey = ffjtDataPap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataOap, kn) {
					currentKey = ffjtDataOap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataNap, kn) {
					currentKey = ffjtDataNap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataMap, kn) {
					currentKey = ffjtDataMap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataJap, kn) {
					currentKey = ffjtDataJap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataIap, kn) {
					currentKey = ffjtDataIap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataHap, kn) {
					currentKey = ffjtDataHap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataGap, kn) {
					currentKey = ffjtDataGap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataFap, kn) {
					currentKey = ffjtDataFap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataEap, kn) {
					currentKey = ffjtDataEap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataDap, kn) {
					currentKey = ffjtDataDap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataCap, kn) {
					currentKey = ffjtDataCap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataBap, kn) {
					currentKey = ffjtDataBap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataAap, kn) {
					currentKey = ffjtDataAap
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataRa, kn) {
					currentKey = ffjtDataRa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataQa, kn) {
					currentKey = ffjtDataQa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataPa, kn) {
					currentKey = ffjtDataPa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataOa, kn) {
					currentKey = ffjtDataOa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataNa, kn) {
					currentKey = ffjtDataNa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataMa, kn) {
					currentKey = ffjtDataMa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataJa, kn) {
					currentKey = ffjtDataJa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataIa, kn) {
					currentKey = ffjtDataIa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataHa, kn) {
					currentKey = ffjtDataHa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataGa, kn) {
					currentKey = ffjtDataGa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataFa, kn) {
					currentKey = ffjtDataFa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataEa, kn) {
					currentKey = ffjtDataEa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataDa, kn) {
					currentKey = ffjtDataDa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataCa, kn) {
					currentKey = ffjtDataCa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataBa, kn) {
					currentKey = ffjtDataBa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataAa, kn) {
					currentKey = ffjtDataAa
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDataSp, kn) {
					currentKey = ffjtDataSp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataRp, kn) {
					currentKey = ffjtDataRp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataQp, kn) {
					currentKey = ffjtDataQp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataPp, kn) {
					currentKey = ffjtDataPp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataOp, kn) {
					currentKey = ffjtDataOp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataNp, kn) {
					currentKey = ffjtDataNp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataMp, kn) {
					currentKey = ffjtDataMp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataJp, kn) {
					currentKey = ffjtDataJp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataIP, kn) {
					currentKey = ffjtDataIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataHp, kn) {
					currentKey = ffjtDataHp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataGp, kn) {
					currentKey = ffjtDataGp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataFp, kn) {
					currentKey = ffjtDataFp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataEp, kn) {
					currentKey = ffjtDataEp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataDp, kn) {
					currentKey = ffjtDataDp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataCp, kn) {
					currentKey = ffjtDataCp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataBp, kn) {
					currentKey = ffjtDataBp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataAp, kn) {
					currentKey = ffjtDataAp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDataS, kn) {
					currentKey = ffjtDataS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataR, kn) {
					currentKey = ffjtDataR
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataQ, kn) {
					currentKey = ffjtDataQ
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataP, kn) {
					currentKey = ffjtDataP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataO, kn) {
					currentKey = ffjtDataO
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataN, kn) {
					currentKey = ffjtDataN
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataM, kn) {
					currentKey = ffjtDataM
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataJ, kn) {
					currentKey = ffjtDataJ
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataI, kn) {
					currentKey = ffjtDataI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataH, kn) {
					currentKey = ffjtDataH
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataG, kn) {
					currentKey = ffjtDataG
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataF, kn) {
					currentKey = ffjtDataF
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataE, kn) {
					currentKey = ffjtDataE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataD, kn) {
					currentKey = ffjtDataD
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataC, kn) {
					currentKey = ffjtDataC
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataB, kn) {
					currentKey = ffjtDataB
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDataA, kn) {
					currentKey = ffjtDataA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDataA:
					goto handle_A

				case ffjtDataB:
					goto handle_B

				case ffjtDataC:
					goto handle_C

				case ffjtDataD:
					goto handle_D

				case ffjtDataE:
					goto handle_E

				case ffjtDataF:
					goto handle_F

				case ffjtDataG:
					goto handle_G

				case ffjtDataH:
					goto handle_H

				case ffjtDataI:
					goto handle_I

				case ffjtDataJ:
					goto handle_J

				case ffjtDataM:
					goto handle_M

				case ffjtDataN:
					goto handle_N

				case ffjtDataO:
					goto handle_O

				case ffjtDataP:
					goto handle_P

				case ffjtDataQ:
					goto handle_Q

				case ffjtDataR:
					goto handle_R

				case ffjtDataS:
					goto handle_S

				case ffjtDataAp:
					goto handle_Ap

				case ffjtDataBp:
					goto handle_Bp

				case ffjtDataCp:
					goto handle_Cp

				case ffjtDataDp:
					goto handle_Dp

				case ffjtDataEp:
					goto handle_Ep

				case ffjtDataFp:
					goto handle_Fp

				case ffjtDataGp:
					goto handle_Gp

				case ffjtDataHp:
					goto handle_Hp

				case ffjtDataIP:
					goto handle_IP

				case ffjtDataJp:
					goto handle_Jp

				case ffjtDataMp:
					goto handle_Mp

				case ffjtDataNp:
					goto handle_Np

				case ffjtDataOp:
					goto handle_Op

				case ffjtDataPp:
					goto handle_Pp

				case ffjtDataQp:
					goto handle_Qp

				case ffjtDataRp:
					goto handle_Rp

				case ffjtDataSp:
					goto handle_Sp

				case ffjtDataAa:
					goto handle_Aa

				case ffjtDataBa:
					goto handle_Ba

				case ffjtDataCa:
					goto handle_Ca

				case ffjtDataDa:
					goto handle_Da

				case ffjtDataEa:
					goto handle_Ea

				case ffjtDataFa:
					goto handle_Fa

				case ffjtDataGa:
					goto handle_Ga

				case ffjtDataHa:
					goto handle_Ha

				case ffjtDataIa:
					goto handle_Ia

				case ffjtDataJa:
					goto handle_Ja

				case ffjtDataMa:
					goto handle_Ma

				case ffjtDataNa:
					goto handle_Na

				case ffjtDataOa:
					goto handle_Oa

				case ffjtDataPa:
					goto handle_Pa

				case ffjtDataQa:
					goto handle_Qa

				case ffjtDataRa:
					goto handle_Ra

				case ffjtDataAap:
					goto handle_Aap

				case ffjtDataBap:
					goto handle_Bap

				case ffjtDataCap:
					goto handle_Cap

				case ffjtDataDap:
					goto handle_Dap

				case ffjtDataEap:
					goto handle_Eap

				case ffjtDataFap:
					goto handle_Fap

				case ffjtDataGap:
					goto handle_Gap

				case ffjtDataHap:
					goto handle_Hap

				case ffjtDataIap:
					goto handle_Iap

				case ffjtDataJap:
					goto handle_Jap

				case ffjtDataMap:
					goto handle_Map

				case ffjtDataNap:
					goto handle_Nap

				case ffjtDataOap:
					goto handle_Oap

				case ffjtDataPap:
					goto handle_Pap

				case ffjtDataQap:
					goto handle_Qap

				case ffjtDataRap:
					goto handle_Rap

				case ffjtDatanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_A:

	/* handler: j.A type=uint8 kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.A = uint8(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_B:

	/* handler: j.B type=uint16 kind=uint16 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint16", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 16)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.B = uint16(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_C:

	/* handler: j.C type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.C = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_D:

	/* handler: j.D type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.D = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_E:

	/* handler: j.E type=int8 kind=int8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.E = int8(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_F:

	/* handler: j.F type=int16 kind=int16 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int16", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 16)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.F = int16(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_G:

	/* handler: j.G type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.G = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_H:

	/* handler: j.H type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.H = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_I:

	/* handler: j.I type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.I = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_J:

	/* handler: j.J type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.J = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M:

	/* handler: j.M type=uint8 kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.M = uint8(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_N:

	/* handler: j.N type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.N = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_O:

	/* handler: j.O type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.O = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_P:

	/* handler: j.P type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.P = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Q:

	/* handler: j.Q type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Q = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_R:

	/* handler: j.R type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.R = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.R = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_S:

	/* handler: j.S type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.S.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ap:

	/* handler: j.Ap type=uint8 kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Ap = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint8(tval)
			j.Ap = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bp:

	/* handler: j.Bp type=uint16 kind=uint16 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint16", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Bp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 16)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint16(tval)
			j.Bp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cp:

	/* handler: j.Cp type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Cp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			j.Cp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dp:

	/* handler: j.Dp type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Dp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			j.Dp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ep:

	/* handler: j.Ep type=int8 kind=int8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Ep = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int8(tval)
			j.Ep = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fp:

	/* handler: j.Fp type=int16 kind=int16 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int16", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Fp = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 16)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int16(tval)
			j.Fp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gp:

	/* handler: j.Gp type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Gp = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			j.Gp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hp:

	/* handler: j.Hp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Hp = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			j.Hp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IP:

	/* handler: j.IP type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.IP = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float32(tval)
			j.IP = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Jp:

	/* handler: j.Jp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Jp = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			j.Jp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mp:

	/* handler: j.Mp type=uint8 kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Mp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint8(tval)
			j.Mp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Np:

	/* handler: j.Np type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Np = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			j.Np = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Op:

	/* handler: j.Op type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Op = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			j.Op = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pp:

	/* handler: j.Pp type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			j.Pp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint(tval)
			j.Pp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Qp:

	/* handler: j.Qp type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.Qp = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.Qp = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rp:

	/* handler: j.Rp type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			j.Rp = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			j.Rp = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sp:

	/* handler: j.Sp type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Sp = nil

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			if j.Sp == nil {
				j.Sp = new(time.Time)
			}

			err = j.Sp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Aa:

	/* handler: j.Aa type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Aa = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&j.Aa).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ba:

	/* handler: j.Ba type=[]uint16 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ba = nil
		} else {

			j.Ba = []uint16{}

			wantVal := true

			for {

				var tmpJBa uint16

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJBa type=uint16 kind=uint16 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint16", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 16)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJBa = uint16(tval)

					}
				}

				j.Ba = append(j.Ba, tmpJBa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ca:

	/* handler: j.Ca type=[]uint32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ca = nil
		} else {

			j.Ca = []uint32{}

			wantVal := true

			for {

				var tmpJCa uint32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCa type=uint32 kind=uint32 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJCa = uint32(tval)

					}
				}

				j.Ca = append(j.Ca, tmpJCa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Da:

	/* handler: j.Da type=[]uint64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Da = nil
		} else {

			j.Da = []uint64{}

			wantVal := true

			for {

				var tmpJDa uint64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDa type=uint64 kind=uint64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJDa = uint64(tval)

					}
				}

				j.Da = append(j.Da, tmpJDa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ea:

	/* handler: j.Ea type=[]int8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ea = nil
		} else {

			j.Ea = []int8{}

			wantVal := true

			for {

				var tmpJEa int8

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEa type=int8 kind=int8 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int8", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 8)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJEa = int8(tval)

					}
				}

				j.Ea = append(j.Ea, tmpJEa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fa:

	/* handler: j.Fa type=[]int16 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Fa = nil
		} else {

			j.Fa = []int16{}

			wantVal := true

			for {

				var tmpJFa int16

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFa type=int16 kind=int16 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int16", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 16)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJFa = int16(tval)

					}
				}

				j.Fa = append(j.Fa, tmpJFa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ga:

	/* handler: j.Ga type=[]int32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ga = nil
		} else {

			j.Ga = []int32{}

			wantVal := true

			for {

				var tmpJGa int32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGa type=int32 kind=int32 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJGa = int32(tval)

					}
				}

				j.Ga = append(j.Ga, tmpJGa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ha:

	/* handler: j.Ha type=[]int64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ha = nil
		} else {

			j.Ha = []int64{}

			wantVal := true

			for {

				var tmpJHa int64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJHa type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJHa = int64(tval)

					}
				}

				j.Ha = append(j.Ha, tmpJHa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ia:

	/* handler: j.Ia type=[]float32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ia = nil
		} else {

			j.Ia = []float32{}

			wantVal := true

			for {

				var tmpJIa float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJIa type=float32 kind=float32 quoted=false*/

				{
					if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJIa = float32(tval)

					}
				}

				j.Ia = append(j.Ia, tmpJIa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ja:

	/* handler: j.Ja type=[]float64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ja = nil
		} else {

			j.Ja = []float64{}

			wantVal := true

			for {

				var tmpJJa float64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJJa type=float64 kind=float64 quoted=false*/

				{
					if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJJa = float64(tval)

					}
				}

				j.Ja = append(j.Ja, tmpJJa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ma:

	/* handler: j.Ma type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ma = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&j.Ma).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Na:

	/* handler: j.Na type=[]int32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Na = nil
		} else {

			j.Na = []int32{}

			wantVal := true

			for {

				var tmpJNa int32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNa type=int32 kind=int32 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJNa = int32(tval)

					}
				}

				j.Na = append(j.Na, tmpJNa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oa:

	/* handler: j.Oa type=[]int kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Oa = nil
		} else {

			j.Oa = []int{}

			wantVal := true

			for {

				var tmpJOa int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOa type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJOa = int(tval)

					}
				}

				j.Oa = append(j.Oa, tmpJOa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pa:

	/* handler: j.Pa type=[]uint kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Pa = nil
		} else {

			j.Pa = []uint{}

			wantVal := true

			for {

				var tmpJPa uint

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPa type=uint kind=uint quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJPa = uint(tval)

					}
				}

				j.Pa = append(j.Pa, tmpJPa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Qa:

	/* handler: j.Qa type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Qa = nil
		} else {

			j.Qa = []string{}

			wantVal := true

			for {

				var tmpJQa string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJQa type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJQa = string(string(outBuf))

					}
				}

				j.Qa = append(j.Qa, tmpJQa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ra:

	/* handler: j.Ra type=[]bool kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Ra = nil
		} else {

			j.Ra = []bool{}

			wantVal := true

			for {

				var tmpJRa bool

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRa type=bool kind=bool quoted=false*/

				{
					if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
					}
				}

				{
					if tok == fflib.FFTok_null {

					} else {
						tmpb := fs.Output.Bytes()

						if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

							tmpJRa = true

						} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

							tmpJRa = false

						} else {
							err = errors.New("unexpected bytes for true/false value")
							return fs.WrapErr(err)
						}

					}
				}

				j.Ra = append(j.Ra, tmpJRa)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Aap:

	/* handler: j.Aap type=[]*uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Aap = nil
		} else {

			j.Aap = []*uint8{}

			wantVal := true

			for {

				var tmpJAap *uint8

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJAap type=*uint8 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJAap = nil
					} else {
						if tmpJAap == nil {
							tmpJAap = new(uint8)
						}

						/* handler: tmpJAap type=uint8 kind=uint8 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJAap = nil

							} else {

								tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := uint8(tval)
								tmpJAap = &ttypval

							}
						}

					}
				}

				j.Aap = append(j.Aap, tmpJAap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bap:

	/* handler: j.Bap type=[]*uint16 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Bap = nil
		} else {

			j.Bap = []*uint16{}

			wantVal := true

			for {

				var tmpJBap *uint16

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJBap type=*uint16 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJBap = nil
					} else {
						if tmpJBap == nil {
							tmpJBap = new(uint16)
						}

						/* handler: tmpJBap type=uint16 kind=uint16 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint16", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJBap = nil

							} else {

								tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 16)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := uint16(tval)
								tmpJBap = &ttypval

							}
						}

					}
				}

				j.Bap = append(j.Bap, tmpJBap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cap:

	/* handler: j.Cap type=[]*uint32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Cap = nil
		} else {

			j.Cap = []*uint32{}

			wantVal := true

			for {

				var tmpJCap *uint32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCap type=*uint32 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJCap = nil
					} else {
						if tmpJCap == nil {
							tmpJCap = new(uint32)
						}

						/* handler: tmpJCap type=uint32 kind=uint32 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJCap = nil

							} else {

								tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := uint32(tval)
								tmpJCap = &ttypval

							}
						}

					}
				}

				j.Cap = append(j.Cap, tmpJCap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dap:

	/* handler: j.Dap type=[]*uint64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Dap = nil
		} else {

			j.Dap = []*uint64{}

			wantVal := true

			for {

				var tmpJDap *uint64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDap type=*uint64 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJDap = nil
					} else {
						if tmpJDap == nil {
							tmpJDap = new(uint64)
						}

						/* handler: tmpJDap type=uint64 kind=uint64 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJDap = nil

							} else {

								tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := uint64(tval)
								tmpJDap = &ttypval

							}
						}

					}
				}

				j.Dap = append(j.Dap, tmpJDap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Eap:

	/* handler: j.Eap type=[]*int8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Eap = nil
		} else {

			j.Eap = []*int8{}

			wantVal := true

			for {

				var tmpJEap *int8

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEap type=*int8 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJEap = nil
					} else {
						if tmpJEap == nil {
							tmpJEap = new(int8)
						}

						/* handler: tmpJEap type=int8 kind=int8 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int8", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJEap = nil

							} else {

								tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 8)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := int8(tval)
								tmpJEap = &ttypval

							}
						}

					}
				}

				j.Eap = append(j.Eap, tmpJEap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fap:

	/* handler: j.Fap type=[]*int16 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Fap = nil
		} else {

			j.Fap = []*int16{}

			wantVal := true

			for {

				var tmpJFap *int16

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFap type=*int16 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJFap = nil
					} else {
						if tmpJFap == nil {
							tmpJFap = new(int16)
						}

						/* handler: tmpJFap type=int16 kind=int16 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int16", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJFap = nil

							} else {

								tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 16)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := int16(tval)
								tmpJFap = &ttypval

							}
						}

					}
				}

				j.Fap = append(j.Fap, tmpJFap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gap:

	/* handler: j.Gap type=[]*int32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Gap = nil
		} else {

			j.Gap = []*int32{}

			wantVal := true

			for {

				var tmpJGap *int32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGap type=*int32 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJGap = nil
					} else {
						if tmpJGap == nil {
							tmpJGap = new(int32)
						}

						/* handler: tmpJGap type=int32 kind=int32 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJGap = nil

							} else {

								tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := int32(tval)
								tmpJGap = &ttypval

							}
						}

					}
				}

				j.Gap = append(j.Gap, tmpJGap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hap:

	/* handler: j.Hap type=[]*int64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Hap = nil
		} else {

			j.Hap = []*int64{}

			wantVal := true

			for {

				var tmpJHap *int64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJHap type=*int64 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJHap = nil
					} else {
						if tmpJHap == nil {
							tmpJHap = new(int64)
						}

						/* handler: tmpJHap type=int64 kind=int64 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJHap = nil

							} else {

								tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := int64(tval)
								tmpJHap = &ttypval

							}
						}

					}
				}

				j.Hap = append(j.Hap, tmpJHap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Iap:

	/* handler: j.Iap type=[]*float32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Iap = nil
		} else {

			j.Iap = []*float32{}

			wantVal := true

			for {

				var tmpJIap *float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJIap type=*float32 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJIap = nil
					} else {
						if tmpJIap == nil {
							tmpJIap = new(float32)
						}

						/* handler: tmpJIap type=float32 kind=float32 quoted=false*/

						{
							if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJIap = nil

							} else {

								tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := float32(tval)
								tmpJIap = &ttypval

							}
						}

					}
				}

				j.Iap = append(j.Iap, tmpJIap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Jap:

	/* handler: j.Jap type=[]*float64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Jap = nil
		} else {

			j.Jap = []*float64{}

			wantVal := true

			for {

				var tmpJJap *float64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJJap type=*float64 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJJap = nil
					} else {
						if tmpJJap == nil {
							tmpJJap = new(float64)
						}

						/* handler: tmpJJap type=float64 kind=float64 quoted=false*/

						{
							if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJJap = nil

							} else {

								tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := float64(tval)
								tmpJJap = &ttypval

							}
						}

					}
				}

				j.Jap = append(j.Jap, tmpJJap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Map:

	/* handler: j.Map type=[]*uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Map = nil
		} else {

			j.Map = []*uint8{}

			wantVal := true

			for {

				var tmpJMap *uint8

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMap type=*uint8 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJMap = nil
					} else {
						if tmpJMap == nil {
							tmpJMap = new(uint8)
						}

						/* handler: tmpJMap type=uint8 kind=uint8 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint8", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJMap = nil

							} else {

								tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := uint8(tval)
								tmpJMap = &ttypval

							}
						}

					}
				}

				j.Map = append(j.Map, tmpJMap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nap:

	/* handler: j.Nap type=[]*int32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Nap = nil
		} else {

			j.Nap = []*int32{}

			wantVal := true

			for {

				var tmpJNap *int32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNap type=*int32 kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJNap = nil
					} else {
						if tmpJNap == nil {
							tmpJNap = new(int32)
						}

						/* handler: tmpJNap type=int32 kind=int32 quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJNap = nil

							} else {

								tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := int32(tval)
								tmpJNap = &ttypval

							}
						}

					}
				}

				j.Nap = append(j.Nap, tmpJNap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oap:

	/* handler: j.Oap type=[]*int kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Oap = nil
		} else {

			j.Oap = []*int{}

			wantVal := true

			for {

				var tmpJOap *int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOap type=*int kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJOap = nil
					} else {
						if tmpJOap == nil {
							tmpJOap = new(int)
						}

						/* handler: tmpJOap type=int kind=int quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJOap = nil

							} else {

								tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := int(tval)
								tmpJOap = &ttypval

							}
						}

					}
				}

				j.Oap = append(j.Oap, tmpJOap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pap:

	/* handler: j.Pap type=[]*uint kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Pap = nil
		} else {

			j.Pap = []*uint{}

			wantVal := true

			for {

				var tmpJPap *uint

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPap type=*uint kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJPap = nil
					} else {
						if tmpJPap == nil {
							tmpJPap = new(uint)
						}

						/* handler: tmpJPap type=uint kind=uint quoted=false*/

						{
							if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
							}
						}

						{

							if tok == fflib.FFTok_null {

								tmpJPap = nil

							} else {

								tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

								if err != nil {
									return fs.WrapErr(err)
								}

								ttypval := uint(tval)
								tmpJPap = &ttypval

							}
						}

					}
				}

				j.Pap = append(j.Pap, tmpJPap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Qap:

	/* handler: j.Qap type=[]*string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Qap = nil
		} else {

			j.Qap = []*string{}

			wantVal := true

			for {

				var tmpJQap *string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJQap type=*string kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJQap = nil
					} else {
						if tmpJQap == nil {
							tmpJQap = new(string)
						}

						/* handler: tmpJQap type=string kind=string quoted=false*/

						{

							{
								if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
								}
							}

							if tok == fflib.FFTok_null {

								tmpJQap = nil

							} else {

								var tval string
								outBuf := fs.Output.Bytes()

								tval = string(string(outBuf))
								tmpJQap = &tval

							}
						}

					}
				}

				j.Qap = append(j.Qap, tmpJQap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rap:

	/* handler: j.Rap type=[]*bool kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Rap = nil
		} else {

			j.Rap = []*bool{}

			wantVal := true

			for {

				var tmpJRap *bool

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRap type=*bool kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJRap = nil
					} else {
						if tmpJRap == nil {
							tmpJRap = new(bool)
						}

						/* handler: tmpJRap type=bool kind=bool quoted=false*/

						{
							if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
								return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
							}
						}

						{
							if tok == fflib.FFTok_null {

								tmpJRap = nil

							} else {
								tmpb := fs.Output.Bytes()

								var tval bool

								if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

									tval = true

								} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

									tval = false

								} else {
									err = errors.New("unexpected bytes for true/false value")
									return fs.WrapErr(err)
								}

								tmpJRap = &tval

							}
						}

					}
				}

				j.Rap = append(j.Rap, tmpJRap)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
